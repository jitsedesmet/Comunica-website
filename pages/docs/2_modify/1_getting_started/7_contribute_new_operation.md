---
title: 'Contributing a new algebra operation'
description: 'Extend the SPARQL parser, register a new algebra Operation, and implement an actor to handle that new operation'
---

This guide focuses on all the required steps for extending the SPARQl parser in order to parse a new [Pattern](https://www.w3.org/TR/sparql11-query/#rGraphPatternNotTriples), as well as extending the algebra itself to transform the modified [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree) into an [Algebra Operation](link to comunica code) that can contain the new Pattern as an algebra operation.
In the end we will tie this back into Comunica and implement an actor that can perform the new Operation.
To this end, we will implement [Lateral](https://github.com/w3c/sparql-dev/blob/main/SEP/SEP-0006/sep-0006.md) in this guide.

<div class="note">
Extending the Parser and Algebra is a very strong feat that is accomplished by
<a href="https://github.com/comunica/traqula">Traqula</a>,
a modular Parser, Generator and Transformer Framework maintained by Comunica.
The codebase and architecture differs greatly from that of the main Comunica project,
if you want to completely understand this tutorial, you are advised to also read into Traqula's documentation.
</div>

## 1. Getting started

Start setting up you development environment as mentioned [here in section 1 and 2](5_contribute_actor.md#1-requirements).
Afterward, [make a new actor](https://comunica.dev/docs/modify/getting_started/contribute_actor/#3--creating-a-new-package) that will allow us to parse SPARQL queries that include the `lateral` pattern: `yo comunica:actor`.
We will name the actor `lateral` on the `query-parse` bus, you can agree with the default options the program suggests.
This actor will mimic the implementation of [ActorQueryParseSparql](https://github.com/comunica/comunica/tree/master/packages/actor-query-parse-sparql), but using our own Parser and Algebra Transformer. We therefore recommend you start by copying the implementation of that actor.

## 2. Creating the parser

We assume you have a base understanding of how [Traqula](https://github.com/comunica/traqula) works.
To implement Lateral ontop of the SPARQL 1.2 parser, we take a look at the [SPARQL 1.2 grammar](https://www.w3.org/TR/sparql12-query/#sparqlGrammar) and look how we should modify it to parse [Lateral](https://github.com/w3c/sparql-dev/blob/main/SEP/SEP-0006/sep-0006.md#syntax-1). We notice that we should alter the [GraphPatternNotTriples](https://www.w3.org/TR/sparql12-query/#rGraphPatternNotTriples) rule to also parse Lateral.

Next we look at how we want to modify the generated AST.
Looking at the AST generated by the [SPARQL1.2 parser](https://github.com/comunica/traqula/blob/a687b53712ce04a82ff32668b8741711678389c4/packages/rules-sparql-1-2/lib/sparql12Types.ts#L4-L18) we conclude that we want to broaden our [Pattern type](https://github.com/comunica/traqula/blob/main/packages/rules-sparql-1-2/lib/sparql12Types.ts#L244-L255) to include the Lateral pattern:
```ts
import type * as T12 from '@traqula/rules-sparql-1-2';
export type Pattern = T12.Pattern | PatternLateral;
export type PatternLateral = T12.PatternBase & {
  subType: 'lateral';
  patterns: Pattern[];
};
```

To parse the lateral grammar rule, start from [the existing SPARQL 1.2 LexerBuilder](https://github.com/comunica/traqula/blob/a687b53712ce04a82ff32668b8741711678389c4/packages/rules-sparql-1-2/lib/lexer.ts#L38) to also parse `lateral` in a case-insensitive way:
```ts
import { createToken, LexerBuilder } from '@traqula/core';
import { lex as l12 } from '@traqula/rules-sparql-1-2';
const lateral = createToken({ name: 'Lateral', pattern: /lateral/i, label: 'Lateral pattern' });
const lateralLexer = LexerBuilder
  .create(l12.sparql12LexerBuilder)
  .add(lateral);
```

To create the parser, we start from [the existing SPARQL 1.2 LexerBuilder](https://github.com/comunica/traqula/blob/a687b53712ce04a82ff32668b8741711678389c4/engines/parser-sparql-1-2/lib/Parser.ts#L12), modifying the `graphPatternNotTriples` rule and adding the `lateralGraphPattern` rule like so:
```ts
import { ParserBuilder } from '@traqula/core';
import { sparql12ParserBuilder } from '@traqula/parser-sparql-1-2';
const comunicaParserBuilder = ParserBuilder.create(sparql12ParserBuilder)
  .patchRule(graphPatternNotTriples)
  .addRule(lateralGraphPattern);
```

To create the grammar rules themselves, we require the `groupGraphPattern` and `graphPatternNotTriples` rules used by the SPARQL 1.2 parser, which we can retrieve using `.getRule`. Afterward we can implement the rules:
```ts
const origGraphPatternNotTriplesParserRule = sparql12ParserBuilder.getRule('graphPatternNotTriples');
const origGroupGraphPatternParserRule = sparql12ParserBuilder.getRule('groupGraphPattern');

const graphPatternNotTriples: T12.SparqlRule<'graphPatternNotTriples', T12.Pattern | PatternLateral> = {
  name: 'graphPatternNotTriples',
  impl: $ => C => $.OR2<RuleDefReturn<typeof graphPatternNotTriples>>([
    { ALT: () => $.SUBRULE(lateralGraphPattern) },
    { ALT: () => origGraphPatternNotTriplesParserRule.impl($)(C) },
  ]),
};

const lateralGraphPattern: T12.SparqlRule<'lateralGraphPattern', PatternLateral> = {
  name: 'lateralGraphPattern',
  impl: ({ CONSUME, SUBRULE, ACTION }) => (C) => {
    const token = CONSUME(lateral);
    const group = SUBRULE(origGroupGraphPatternParserRule);
    return ACTION(() => ({
      type: 'pattern',
      subType: 'lateral',
      patterns: group.patterns,
      loc: C.astFactory.sourceLocation(token, group),
    } satisfies PatternLateral));
  },
};
```

These few snippets are enough to get a functionally correct parser from `comunicaParserBuilder.build()`.
Not that the types of this parser will not yet include the LateralType, to achieve this some type-patching needs to be done which is out of scope.


## 3. Creating the algebra

After implementing the parser, we need to look at how Traqula's algebra transformer needs to be manipulated.
Here it is important to note that Comunica maintains its own representation of the Algebra.
Comunica does this because it wants to open the algebra for unknown operations thereby offering some user-friendliness. Essentially this means that Comunica sees an operation as an interface instead of a union of known algebra operations.
Due to some limitations in components.JS, it is recommended to declare your custom operations using Traqula's algebra, and _open the type_ using Comunica's helper:
```ts
import type { Algebra as TraqulaAlgebra } from '@traqula/algebra-transformations-1-2';
// We need to confuse componentsJS enough with complex types.
export type Lateral = Algebra.Opened<TraqulaAlgebra.Double & {
  type: 'lateral';
}>;
```

From an implementation perspective, knowing what algebra translation rules need to change, currently requires knowing how the transformations are performed (a more usable approach would need to be developed). For the pattern manipulations, one can discover that only `accumulateGroupGraphPattern` needs to be altered to also parse the AST's new Lateral pattern:
```ts
import { toAlgebra12Builder } from '@traqula/algebra-sparql-1-2';
import type { AlgebraIndir, Algebra } from '@traqula/algebra-transformations-1-2';
import { IndirBuilder } from '@traqula/core';

const origAccumulateGroupGraphPattern = toAlgebra12Builder.getRule('accumulateGroupGraphPattern');
export const accumulateGroupGraphPattern: AlgebraIndir<'accumulateGroupGraphPattern', Algebra.Operation | Lateral, [Algebra.Operation, Pattern]> = {
  name: 'accumulateGroupGraphPattern',
  fun: $ => (C, algebraOp, pattern) => {
    if (pattern.subType === 'lateral') {
      return {
        type: 'lateral',
        input: [
          algebraOp,
          $.SUBRULE(origTranslateGraphPattern, C.astFactory.patternGroup(<any[]> pattern.patterns, pattern.loc)),
        ],
      } satisfies Lateral;
    }
    return origAccumulateGroupGraphPattern.fun($)(C, algebraOp, pattern);
  },
};

const algebraBuilderComunica = IndirBuilder
  .create(toAlgebra12Builder)
  .patchRule(accumulateGroupGraphPattern);
```

After this, we can just alter our newly created parser actor to use this parser and algebra transformer, and then we are ready to create our actor that will handle the 'lateral' operation.
Afterward, you should also change your engines config to use the new SPARQL parser instead of Comunica's original SPARQL parser.

## 4. Creating the lateral actor

Creating the lateral actor than boils down to following the guide on [implementing your own actor query operation](5_contribute_actor.md#4-implementing-your-actor). You should just make sure that the generic type passed to `ActorQueryOperationTypedMediated` is your `Lateral` type.

